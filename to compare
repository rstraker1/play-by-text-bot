const TelegramBot = require('node-telegram-bot-api');
const express = require('express');
const fs = require('fs');
const path = require('path');

const token = process.env.TELEGRAM_BOT_TOKEN;
const url = process.env.RENDER_EXTERNAL_URL;

if (!token) {
  console.error('TELEGRAM_BOT_TOKEN environment variable not set!');
  process.exit(1);
}

const app = express();
app.use(express.json());

const bot = new TelegramBot(token);

const userProgress = {};
const plays = {};
const playsDir = path.join(__dirname, 'plays');

// Persisted map of { chatId: { lastSeen, messages: { messageId: { playId, lineIndex } } } }
// Lets users reply to any past line with '?' to get its annotation
const messageMapFile = path.join(__dirname, 'messageMap.json');
let messageMap = {};

const CLEANUP_AGE_DAYS = 90;

function loadMessageMap() {
  try {
    if (fs.existsSync(messageMapFile)) {
      messageMap = JSON.parse(fs.readFileSync(messageMapFile, 'utf8'));
    }
  } catch (e) {
    console.error('Failed to load messageMap:', e.message);
    messageMap = {};
  }
}

function saveMessageMap() {
  try {
    fs.writeFileSync(messageMapFile, JSON.stringify(messageMap), 'utf8');
  } catch (e) {
    console.error('Failed to save messageMap:', e.message);
  }
}

function cleanupMessageMap() {
  const cutoff = Date.now() - CLEANUP_AGE_DAYS * 24 * 60 * 60 * 1000;
  let removed = 0;
  for (const chatId of Object.keys(messageMap)) {
    const lastSeen = messageMap[chatId].lastSeen || 0;
    if (lastSeen < cutoff) {
      delete messageMap[chatId];
      removed++;
    }
  }
  if (removed > 0) {
    console.log(`Cleaned up ${removed} inactive chat(s) from messageMap`);
    saveMessageMap();
  }
}

function recordMessage(chatId, messageId, playId, lineIndex) {
  if (!messageMap[chatId]) messageMap[chatId] = { lastSeen: null, messages: {} };
  messageMap[chatId].messages[messageId] = { playId, lineIndex };
  messageMap[chatId].lastSeen = Date.now();
  saveMessageMap();
}

function lookupMessage(chatId, messageId) {
  return messageMap[chatId]?.messages?.[messageId] || null;
}

function loadPlays() {
  if (!fs.existsSync(playsDir)) {
    fs.mkdirSync(playsDir, { recursive: true });
  }
  const files = fs.readdirSync(playsDir).filter(f => f.endsWith('.json'));
  for (const file of files) {
    const playId = file.replace('.json', '');
    const data = JSON.parse(fs.readFileSync(path.join(playsDir, file), 'utf8'));
    plays[playId] = data;
    console.log(`Loaded play: ${data.title}`);
  }
  console.log(`Total plays loaded: ${Object.keys(plays).length}`);
}

function getUserProgress(chatId) {
  if (!userProgress[chatId]) {
    userProgress[chatId] = { currentPlay: null, currentLine: 0, lastMessageId: null, lastAnnotationId: null };
  }
  return userProgress[chatId];
}

function formatLine(line) {
  if (line.type === 'stage') {
    return `ðŸ“ *Stage*\n_${line.text}_\n`;
  }
  return `${line.avatar || 'ðŸŽ­'} *${line.sender}*\n${line.text}\n`;
}

async function sendLine(chatId, playId, lineIndex) {
  const play = plays[playId];
  if (!play) return;
  const line = play.lines[lineIndex];
  if (!line) return;

  const progress = getUserProgress(chatId);
  const isLastLine = lineIndex >= play.lines.length - 1;
  const keyboard = [];

  if (!isLastLine) {
    keyboard.push([{ text: 'Next â–¶ï¸', callback_data: `next_${playId}_${lineIndex + 1}` }]);
  } else {
    keyboard.push([{ text: 'âœ… Fin', callback_data: 'fin' }]);
  }
  if (line.annotation) {
    keyboard[0].unshift({ text: '?', callback_data: `annotate_${playId}_${lineIndex}` });
  }

  try {
    const sent = await bot.sendMessage(chatId, formatLine(line), {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: keyboard }
    });
    progress.currentPlay = playId;
    progress.currentLine = lineIndex;
    progress.lastMessageId = sent.message_id;

    // Persist the messageâ†’line mapping for reply-? lookups
    recordMessage(chatId, sent.message_id, playId, lineIndex);
  } catch (error) {
    console.error('Error sending message:', error.message);
  }
}

async function sendAnnotation(chatId, playId, lineIndex) {
  const play = plays[playId];
  if (!play) return;
  const line = play.lines[lineIndex];
  if (!line || !line.annotation) return;

  const progress = getUserProgress(chatId);

  try {
    const sent = await bot.sendMessage(chatId, `ðŸ“– *Annotation*\n\n${line.annotation}`, { parse_mode: 'Markdown' });
    progress.lastAnnotationId = sent.message_id;
  } catch (error) {
    const sent = await bot.sendMessage(chatId, `ðŸ“– Annotation\n\n${line.annotation}`);
    progress.lastAnnotationId = sent.message_id;
  }
}

async function handleMessage(msg) {
  const chatId = msg.chat.id;
  const text = msg.text?.trim();

  // Reply '?' to any past line â†’ fetch its annotation
  if (text === '?' && msg.reply_to_message) {
    const repliedId = msg.reply_to_message.message_id;
    const entry = lookupMessage(chatId, repliedId);
    if (entry) {
      await sendAnnotation(chatId, entry.playId, entry.lineIndex);
    }
    return;
  }

  if (text === '/start') {
    const progress = getUserProgress(chatId);
    progress.currentPlay = null;
    progress.currentLine = 0;

    const playList = Object.entries(plays).map(([id, play]) => {
      return [{ text: `${play.emoji || 'ðŸŽ­'} ${play.title}`, callback_data: `start_${id}` }];
    });

    if (playList.length === 0) {
      await bot.sendMessage(chatId, 'ðŸŽ­ *Play by Text*\n\nNo plays available yet.', { parse_mode: 'Markdown' });
      return;
    }

    await bot.sendMessage(chatId,
      'ðŸŽ­ *Play by Text*\n\nClassic plays, delivered line by line.\n\nChoose a play to begin:\n\n_Tip: Type /start anytime to return to this menu_', {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: playList }
    });
  } else if (text === '/help') {
    await bot.sendMessage(chatId,
      `ðŸŽ­ *Play by Text â€” Help*\n\nâ€¢ Press *Next â–¶ï¸* to advance\nâ€¢ Press *?* for the current line's annotation\nâ€¢ Reply to any line with *?* to get its annotation\n\n/start â€” Choose a play\n/plays â€” List plays`,
      { parse_mode: 'Markdown' }
    );
  } else if (text === '/plays') {
    const playList = Object.entries(plays).map(([id, play]) => {
      return [{ text: `${play.emoji || 'ðŸŽ­'} ${play.title}`, callback_data: `start_${id}` }];
    });
    await bot.sendMessage(chatId, 'ðŸ“š *Available Plays*', {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: playList }
    });
  }
}

async function handleCallbackQuery(query) {
  const chatId = query.message.chat.id;
  const data = query.data;

  await bot.answerCallbackQuery(query.id);

  if (data.startsWith('start_')) {
    const playId = data.replace('start_', '');
    const play = plays[playId];
    if (play) {
      await bot.sendMessage(
        chatId,
        `ðŸŽ­ *${play.title}*\n_${play.author}_\n\n${play.description || ''}\n\n_Tip: reply to any line with ? to get its annotation._\n\nStarting...`,
        { parse_mode: 'Markdown' }
      );
      setTimeout(() => sendLine(chatId, playId, 0), 1000);
    }
  } else if (data.startsWith('next_')) {
    const parts = data.split('_');
    const playId = parts[1];
    const lineIndex = parseInt(parts[2], 10);

    // Remove buttons from the previous line message
    try {
      await bot.editMessageReplyMarkup({ inline_keyboard: [] }, { chat_id: chatId, message_id: query.message.message_id });
    } catch (e) {}

    // Delete any open annotation message
    const progress = getUserProgress(chatId);
    if (progress.lastAnnotationId) {
      try {
        await bot.deleteMessage(chatId, progress.lastAnnotationId);
      } catch (e) {}
      progress.lastAnnotationId = null;
    }

    await sendLine(chatId, playId, lineIndex);
  } else if (data.startsWith('annotate_')) {
    const parts = data.split('_');
    await sendAnnotation(chatId, parts[1], parseInt(parts[2], 10));
  } else if (data === 'fin') {
    await bot.sendMessage(chatId, 'ðŸŽ­ *Fin*\n\nThank you for reading!\n\n/plays for another.', { parse_mode: 'Markdown' });
  }
}

// Stats endpoint â€” visit /stats to see messageMap health
app.get('/stats', (req, res) => {
  const size = fs.existsSync(messageMapFile) ? fs.statSync(messageMapFile).size : 0;
  const users = Object.keys(messageMap).length;
  const totalMessages = Object.values(messageMap).reduce((acc, m) => acc + Object.keys(m.messages || {}).length, 0);
  res.json({ users, totalMessages, fileSizeKB: (size / 1024).toFixed(1) });
});

app.post(`/webhook/${token}`, (req, res) => {
  if (req.body.message) handleMessage(req.body.message);
  if (req.body.callback_query) handleCallbackQuery(req.body.callback_query);
  res.sendStatus(200);
});

app.get('/', (req, res) => res.send('Play by Text bot is running! ðŸŽ­'));

const PORT = process.env.PORT || 10000;

async function startServer() {
  loadPlays();
  loadMessageMap();
  cleanupMessageMap(); // prune chats inactive for 90+ days on every startup
  app.listen(PORT, async () => {
    console.log(`Server running on port ${PORT}`);
    if (url) {
      const webhookUrl = `${url}/webhook/${token}`;
      await bot.setWebHook(webhookUrl);
      console.log(`Webhook set to: ${webhookUrl}`);
    }
  });
}

startServer();