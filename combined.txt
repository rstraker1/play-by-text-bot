=== File Structure ===
Folder PATH listing for volume Windows-SSD
Volume serial number is 3C43-57B8
C:.
ª   .gitignore
ª   bot.js
ª   combined.txt
ª   package.json
ª   README.md
ª   to compare
ª   
+---images
ª       bear.jpg
ª       proposal.jpg
ª       stronger.jpg
ª       tempest-1-opening-storm.jpg
ª       
+---plays
        bear.json
        proposal.json
        stronger.json
        tempest.json
        

=== .gitignore ===
node_modules/
.env
.DS_Store

=== bot.js ===
const TelegramBot = require('node-telegram-bot-api');
const express = require('express');
const fs = require('fs');
const path = require('path');
const os = require('os');
const { EdgeTTS } = require('node-edge-tts');

const token = process.env.TELEGRAM_BOT_TOKEN;
const url = process.env.RENDER_EXTERNAL_URL;

if (!token) {
  console.error('TELEGRAM_BOT_TOKEN environment variable not set!');
  process.exit(1);
}

const app = express();
app.use(express.json());

app.get('/health', (req, res) => {
  res.status(200).send('OK');
});

const bot = new TelegramBot(token);

const userProgress = {};
const plays = {};
const playsDir = path.join(__dirname, 'plays');

// TTS cache: "playId:lineIndex" -> Telegram file_id
const ttsFileCache = {};

// Default voices
const DEFAULT_NARRATOR_VOICE = 'en-GB-ThomasNeural';
const DEFAULT_CHARACTER_VOICE = 'en-GB-RyanNeural';
const TTS_OUTPUT_FORMAT = 'audio-24khz-48kbitrate-mono-mp3';

// ── Play loading ──

function buildSceneIndex(play) {
  const scenes = [];
  for (let i = 0; i < play.lines.length; i++) {
    const line = play.lines[i];
    if (line.type === 'stage' && /^Act\s/i.test(line.text)) {
      scenes.push({ lineIndex: i, label: line.text });
    }
  }
  return scenes;
}

function loadPlays() {
  if (!fs.existsSync(playsDir)) {
    fs.mkdirSync(playsDir, { recursive: true });
  }
  const files = fs.readdirSync(playsDir).filter(f => f.endsWith('.json'));
  for (const file of files) {
    const playId = file.replace('.json', '');
    const data = JSON.parse(fs.readFileSync(path.join(playsDir, file), 'utf8'));
    data.sceneIndex = buildSceneIndex(data);
    plays[playId] = data;
    console.log(`Loaded play: ${data.title} (${data.sceneIndex.length} scenes)`);
  }
  console.log(`Total plays loaded: ${Object.keys(plays).length}`);
}

// ── Character helpers (support both string emoji and {emoji, voice} objects) ──

function getEmoji(play, senderName) {
  const entry = play.characters?.[senderName];
  if (!entry) return '\u{1F3AD}';
  if (typeof entry === 'string') return entry;
  return entry.emoji || '\u{1F3AD}';
}

function getVoice(play, senderName) {
  const entry = play.characters?.[senderName];
  if (entry && typeof entry === 'object' && entry.voice) return entry.voice;
  return play.defaultVoice || DEFAULT_CHARACTER_VOICE;
}

function getNarratorVoice(play) {
  return play.narrator || DEFAULT_NARRATOR_VOICE;
}

// ── User state ──

function getUserProgress(chatId) {
  if (!userProgress[chatId]) {
    userProgress[chatId] = {
      currentPlay: null,
      currentLine: 0,
      lastMessageId: null,
      lastAnnotationId: null,
      deliveryMode: 'manual',
      audioEnabled: false,
      pendingTimer: null,
      typingTimer: null,
      messageMap: {}
    };
  }
  return userProgress[chatId];
}

// ── Formatting ──

function formatLine(play, line) {
  const avatar = getEmoji(play, line.sender);
  if (line.type === 'stage') {
    return `${avatar} *Stage*\n_${line.text}_`;
  }
  return `${avatar} *${line.sender}*\n${line.text}`;
}

function formatCast(play) {
  if (!play.dramatis || play.dramatis.length === 0) return null;
  const lines = play.dramatis.map(entry => {
    const name = entry.split(/\s*[\u2013\u2014-]\s*/)[0].trim();
    const firstName = name.split(/\s*[&,]\s*/)[0].trim();
    const emoji = getEmoji(play, firstName);
    return `${emoji}  ${entry}`;
  });
  return `\u{1F4DC} *Cast*\n\n${lines.join('\n')}`;
}

// ── Delivery modes ──

const MODE_EMOJI = { manual: '\u23F8', ambient: '\u{1F56F}\uFE0F', active: '\u25B6' };
const MODE_NEXT  = { manual: 'ambient', ambient: 'active', active: 'manual' };

function clearTimers(progress) {
  if (progress.pendingTimer) {
    clearTimeout(progress.pendingTimer);
    progress.pendingTimer = null;
  }
  if (progress.typingTimer) {
    clearTimeout(progress.typingTimer);
    progress.typingTimer = null;
  }
}

function wordCount(line) {
  return line?.text?.split(/\s+/).length || 10;
}

function scheduleNextLine(chatId, playId, lineIndex) {
  const progress = getUserProgress(chatId);

  clearTimers(progress);

  if (progress.deliveryMode === 'manual') return;

  const play = plays[playId];
  if (!play || lineIndex >= play.lines.length) return;

  let delay;
  if (progress.deliveryMode === 'ambient') {
    delay = (10 + Math.random() * 50) * 60 * 1000;
  } else if (progress.deliveryMode === 'active') {
    const prevWords = wordCount(play.lines[lineIndex - 1]);
    const readingTime = (prevWords / 200) * 60 * 1000;
    const beat = 2000 + Math.random() * 1500;
    delay = Math.min(Math.max(readingTime + beat, 3000), 45000);
  }

  const nextWords = wordCount(play.lines[lineIndex]);
  const typingLead = Math.min(
    Math.max(nextWords * 120, 600),
    4000,
    delay - 300
  );

  const typingDelay = Math.max(delay - typingLead, 0);
  progress.typingTimer = setTimeout(async () => {
    progress.typingTimer = null;
    try {
      await bot.sendChatAction(chatId, 'typing');
    } catch (e) {}
  }, typingDelay);

  progress.pendingTimer = setTimeout(async () => {
    progress.pendingTimer = null;
    await sendLine(chatId, playId, lineIndex, false);
  }, delay);
}

// ── TTS audio generation ──

async function generateTTSClip(text, voice) {
  const tmpFile = path.join(os.tmpdir(), `tts_${Date.now()}_${Math.random().toString(36).slice(2)}.mp3`);
  const tts = new EdgeTTS({ voice, outputFormat: TTS_OUTPUT_FORMAT });
  await tts.ttsPromise(text, tmpFile);
  const buf = fs.readFileSync(tmpFile);
  try { fs.unlinkSync(tmpFile); } catch (e) {}
  return buf;
}

function generateSilence(ms) {
  const silentFrame = Buffer.from(
    'fff3e004000000000000000000000000000000000000000000000000000000000000000000000000',
    'hex'
  );
  const framesNeeded = Math.ceil(ms / 26);
  const frames = [];
  for (let i = 0; i < framesNeeded; i++) frames.push(silentFrame);
  return Buffer.concat(frames);
}

async function generateLineAudio(play, line) {
  if (line.type === 'stage') {
    // Narrator reads stage directions directly
    return generateTTSClip(line.text, getNarratorVoice(play));
  }

  // Narrator announces character name, then character voice reads the line
  const [narratorBuf, characterBuf] = await Promise.all([
    generateTTSClip(`${line.sender}.`, getNarratorVoice(play)),
    generateTTSClip(line.text, getVoice(play, line.sender))
  ]);

  const silenceMs = 400;
  const silenceBuf = generateSilence(silenceMs);
  return Buffer.concat([narratorBuf, silenceBuf, characterBuf]);
}

async function sendVoiceForLine(chatId, playId, lineIndex, line, play) {
  const cacheKey = `${playId}:${lineIndex}`;

  try {
    // Check Telegram file_id cache first
    if (ttsFileCache[cacheKey]) {
      await bot.sendVoice(chatId, ttsFileCache[cacheKey]);
      return;
    }

    // Generate fresh audio
    const audioBuffer = await generateLineAudio(play, line);

    const sent = await bot.sendVoice(chatId, audioBuffer, {}, {
      filename: 'line.mp3',
      contentType: 'audio/mpeg'
    });

    // Cache the Telegram file_id for future sends
    if (sent.voice?.file_id) {
      ttsFileCache[cacheKey] = sent.voice.file_id;
    }
  } catch (error) {
    console.error('TTS/voice send error:', error.message);
  }
}

// ── Keyboard builder ──

function buildKeyboard(play, playId, lineIndex, progress) {
  const line = play.lines[lineIndex];
  const isLastLine = lineIndex >= play.lines.length - 1;
  const keyboard = [];

  if (!isLastLine) {
    keyboard.push([{ text: '\u25BD', callback_data: `next:${playId}:${lineIndex + 1}` }]);
  } else {
    keyboard.push([{ text: '\u2705  Fin', callback_data: 'fin' }]);
  }

  // Annotation button
  if (line?.annotation) {
    keyboard[0].unshift({ text: '\u{1F50D}', callback_data: `annotate:${playId}:${lineIndex}` });
  }

  // Mode button
  if (!isLastLine) {
    keyboard[0].push({
      text: MODE_EMOJI[progress.deliveryMode],
      callback_data: `mode:${playId}:${lineIndex + 1}`
    });
  }

  return keyboard;
}

function buildDescriptionKeyboard(play, playId, progress) {
  const keyboard = [[{ text: '\u25BD', callback_data: `next:${playId}:0` }]];

  if (play.introAnnotation) {
    keyboard[0].unshift({ text: '\u{1F50D}', callback_data: `annotate:${playId}:intro` });
  }

  keyboard[0].push({
    text: MODE_EMOJI[progress.deliveryMode],
    callback_data: `mode:${playId}:0`
  });

  return keyboard;
}

// ── Message cleanup ──

async function cleanupPrevious(chatId, manualAdvance = false) {
  const progress = getUserProgress(chatId);

  if (progress.lastMessageId) {
    try {
      await bot.editMessageReplyMarkup(
        { inline_keyboard: [] },
        { chat_id: chatId, message_id: progress.lastMessageId }
      );
    } catch (e) {}
    progress.lastMessageId = null;
  }

  if (progress.lastAnnotationId && (progress.deliveryMode === 'manual' || manualAdvance)) {
    try {
      await bot.deleteMessage(chatId, progress.lastAnnotationId);
    } catch (e) {}
    progress.lastAnnotationId = null;
  }
}

// ── Core line delivery ──

async function sendLine(chatId, playId, lineIndex, manualAdvance = false) {
  const play = plays[playId];
  if (!play) return;
  const line = play.lines[lineIndex];
  if (!line) return;

  const progress = getUserProgress(chatId);

  await cleanupPrevious(chatId, manualAdvance);

  const keyboard = buildKeyboard(play, playId, lineIndex, progress);

  try {
    if (line.image) {
      await bot.sendPhoto(chatId, line.image);
    }
    const sent = await bot.sendMessage(chatId, formatLine(play, line), {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: keyboard }
    });
    progress.currentPlay = playId;
    progress.currentLine = lineIndex;
    progress.lastMessageId = sent.message_id;
    progress.messageMap[sent.message_id] = { playId, lineIndex };
  } catch (error) {
    console.error('Error sending message:', error.message);
  }

  // Send audio if enabled (non-blocking — text is already delivered)
  if (progress.audioEnabled) {
    sendVoiceForLine(chatId, playId, lineIndex, line, play);
  }

  const isLastLine = lineIndex >= play.lines.length - 1;
  if (!isLastLine) {
    scheduleNextLine(chatId, playId, lineIndex + 1);
  }
}

// ── Annotations ──

async function sendAnnotation(chatId, playId, lineIndex) {
  const play = plays[playId];
  if (!play) return;

  let annotationText;
  if (lineIndex === 'intro') {
    annotationText = play.introAnnotation;
  } else {
    const line = play.lines[lineIndex];
    if (!line || !line.annotation) return;
    annotationText = line.annotation;
  }

  if (!annotationText) return;

  const progress = getUserProgress(chatId);

  try {
    const sent = await bot.sendMessage(chatId, `\u{1F50D} *Annotation*\n\n${annotationText}`, { parse_mode: 'Markdown' });
    progress.lastAnnotationId = sent.message_id;
  } catch (error) {
    const sent = await bot.sendMessage(chatId, `\u{1F50D} Annotation\n\n${annotationText}`);
    progress.lastAnnotationId = sent.message_id;
  }
}

// ── Message handler ──

async function handleMessage(msg) {
  const chatId = msg.chat.id;
  const text = msg.text?.trim();

  if (text === '?' && msg.reply_to_message) {
    const progress = getUserProgress(chatId);
    const repliedId = msg.reply_to_message.message_id;
    const entry = progress.messageMap[repliedId];

    if (entry) {
      const play = plays[entry.playId];
      const line = play?.lines[entry.lineIndex];
      if (line?.annotation) {
        await sendAnnotation(chatId, entry.playId, entry.lineIndex);
      } else {
        await bot.sendMessage(chatId, '_No annotation for this line._', { parse_mode: 'Markdown' });
      }
    }
    return;
  }

  if (text === '/start') {
    const progress = getUserProgress(chatId);

    clearTimers(progress);

    progress.currentPlay = null;
    progress.currentLine = 0;
    progress.lastAnnotationId = null;
    progress.messageMap = {};

    const playList = Object.entries(plays).map(([id, play]) => {
      const author = play.author ? ` — ${play.author.split(' ').pop()}` : '';
      const lines = play.lines ? ` · ${play.lines.length} lines` : '';
      return [{ text: `${play.emoji || '🎭'} ${play.title}${author}${lines}`, callback_data: `start:${id}` }];
    });

    if (playList.length === 0) {
      await bot.sendMessage(chatId, '\u{1F3AD} *Play by Text*\n\nNo plays available yet.', { parse_mode: 'Markdown' });
      return;
    }

    await bot.sendMessage(chatId,
      '     \u{1F3AD} Choose a play to begin:\n\n_Type /start anytime to return here, & /help for more info._', {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: playList }
    });

  } else if (text === '/audio') {
    const progress = getUserProgress(chatId);
    progress.audioEnabled = !progress.audioEnabled;

    if (progress.audioEnabled) {
      await bot.sendMessage(chatId, '\u{1F50A} _Audio on \u2014 lines will be narrated aloud._', { parse_mode: 'Markdown' });
    } else {
      await bot.sendMessage(chatId, '\u{1F507} _Audio off._', { parse_mode: 'Markdown' });
    }

  } else if (text === '/help') {
    await bot.sendMessage(chatId,
      `\u{1F3AD} *Play by Text \u2014 Help*\n\n\u2022 Press *\u25BD* to advance\n\u2022 Press *\u{1F50D}* on any line for its annotation\n\u2022 Reply to any line with *?* to get its annotation later\n\u2022 Press the mode button to cycle delivery:\n    \u23F8 Manual \u2014 tap \u25BD yourself\n    \u{1F56F}\uFE0F Ambient \u2014 next line arrives in 10\u201360 min\n    \u25B6 Active \u2014 lines delivered approx reading pace\n\n/start \u2014 Choose a play\n/cast \u2014 Show cast of current play\n/scenes \u2014 Jump to a scene\n/audio \u2014 Toggle audio narration on/off\n/plays \u2014 List plays`,
      { parse_mode: 'Markdown' }
    );

  } else if (text === '/cast') {
    const progress = getUserProgress(chatId);
    if (!progress.currentPlay || !plays[progress.currentPlay]) {
      await bot.sendMessage(chatId, '_No play in progress. Use /start to choose one._', { parse_mode: 'Markdown' });
      return;
    }
    const play = plays[progress.currentPlay];
    const castText = formatCast(play);
    if (castText) {
      try {
        await bot.sendMessage(chatId, castText, { parse_mode: 'Markdown' });
      } catch (e) {
        await bot.sendMessage(chatId, castText);
      }
    } else {
      await bot.sendMessage(chatId, '_No cast list available for this play._', { parse_mode: 'Markdown' });
    }

  } else if (text === '/scenes') {
    const progress = getUserProgress(chatId);
    if (!progress.currentPlay || !plays[progress.currentPlay]) {
      await bot.sendMessage(chatId, '_No play in progress. Use /start to choose one._', { parse_mode: 'Markdown' });
      return;
    }
    const play = plays[progress.currentPlay];
    if (play.sceneIndex.length === 0) {
      await bot.sendMessage(chatId, '_No scene index available for this play._', { parse_mode: 'Markdown' });
      return;
    }
    const buttons = play.sceneIndex.map(s => {
      return [{ text: s.label, callback_data: `next:${progress.currentPlay}:${s.lineIndex}` }];
    });
    await bot.sendMessage(chatId, `${play.emoji || '\u{1F3AD}'} *${play.title}*`, {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: buttons }
    });

} else if (text === '/plays') {
    const playList = Object.entries(plays).map(([id, play]) => {
      const author = play.author ? ` — ${play.author.split(' ').pop()}` : '';
      const lines = play.lines ? ` · ${play.lines.length} lines` : '';
      return [{ text: `${play.emoji || '🎭'} ${play.title}${author}${lines}`, callback_data: `start:${id}` }];
    });
    await bot.sendMessage(chatId, '\u{1F3AD} *Available Plays*', {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: playList }
    });
  }
}

// ── Callback query handler ──

async function handleCallbackQuery(query) {
  const chatId = query.message.chat.id;
  const data = query.data;

  if (data.startsWith('start:')) {
    await bot.answerCallbackQuery(query.id);
    const playId = data.slice('start:'.length);
    const play = plays[playId];
    if (play) {
      const progress = getUserProgress(chatId);
      clearTimers(progress);

      // Title + author
      await bot.sendMessage(
        chatId,
        `${play.emoji || '\u{1F3AD}'} *${play.title}*\n_${play.author}_`,
        { parse_mode: 'Markdown' }
      );

      // Image
      if (play.image) {
        await bot.sendPhoto(chatId, play.image);
      }

      // Description
      if (play.description) {
        await bot.sendMessage(chatId, play.description);
      }

      // Cast (with ▽ button to begin)
      if (play.dramatis && play.dramatis.length > 0) {
        const castText = formatCast(play);
        if (castText) {
          const keyboard = buildDescriptionKeyboard(play, playId, progress);
          try {
            const sent = await bot.sendMessage(chatId, castText, {
              parse_mode: 'Markdown',
              reply_markup: { inline_keyboard: keyboard }
            });
            progress.lastMessageId = sent.message_id;
            progress.currentPlay = playId;
          } catch (e) {
            const sent = await bot.sendMessage(chatId, castText, {
              reply_markup: { inline_keyboard: keyboard }
            });
            progress.lastMessageId = sent.message_id;
            progress.currentPlay = playId;
          }
        }
      } else {
        // No cast — put ▽ on description or just start
        if (play.description) {
          // Description already sent without buttons, so just start
          setTimeout(() => sendLine(chatId, playId, 0, true), 500);
        } else {
          setTimeout(() => sendLine(chatId, playId, 0, true), 500);
        }
      }
    }

  } else if (data.startsWith('next:')) {
    await bot.answerCallbackQuery(query.id);
    const parts = data.split(':');
    const playId = parts[1];
    const lineIndex = parseInt(parts[2], 10);

    const progress = getUserProgress(chatId);
    clearTimers(progress);

    await sendLine(chatId, playId, lineIndex, true);

  } else if (data.startsWith('annotate:')) {
    await bot.answerCallbackQuery(query.id);
    const parts = data.split(':');
    const lineIndex = parts[2] === 'intro' ? 'intro' : parseInt(parts[2], 10);
    await sendAnnotation(chatId, parts[1], lineIndex);

  } else if (data.startsWith('mode:')) {
    const parts = data.split(':');
    const playId = parts[1];
    const nextLineIndex = parseInt(parts[2], 10);

    const progress = getUserProgress(chatId);
    const newMode = MODE_NEXT[progress.deliveryMode];
    progress.deliveryMode = newMode;

    clearTimers(progress);
    scheduleNextLine(chatId, playId, nextLineIndex);

    // Redraw keyboard on current message
    const play = plays[playId];
    if (play && progress.lastMessageId) {
      const currentLineIndex = nextLineIndex - 1;
      const isDescription = currentLineIndex < 0;

      if (isDescription) {
        const keyboard = buildDescriptionKeyboard(play, playId, progress);
        try {
          await bot.editMessageReplyMarkup(
            { inline_keyboard: keyboard },
            { chat_id: chatId, message_id: progress.lastMessageId }
          );
        } catch (e) {}
      } else {
        const keyboard = buildKeyboard(play, playId, currentLineIndex, progress);
        try {
          await bot.editMessageReplyMarkup(
            { inline_keyboard: keyboard },
            { chat_id: chatId, message_id: progress.lastMessageId }
          );
        } catch (e) {}
      }
    }

    await bot.answerCallbackQuery(query.id, {
      text: `${MODE_EMOJI[newMode]} ${newMode.charAt(0).toUpperCase() + newMode.slice(1)} mode`
    });

  } else if (data === 'fin') {
    await bot.answerCallbackQuery(query.id);
    await bot.sendMessage(chatId, '\u{1F3AD} *Fin*\n\nThank you for reading!\n\n/plays for another.', { parse_mode: 'Markdown' });
  }
}

// ── Webhook & server ──

app.post(`/webhook/${token}`, (req, res) => {
  try {
    if (req.body.message) handleMessage(req.body.message);
    if (req.body.callback_query) handleCallbackQuery(req.body.callback_query);
  } catch (error) {
    console.error('Webhook handler error:', error);
  }
  res.sendStatus(200);
});

app.get('/', (req, res) => res.send('Play by Text bot is running! \u{1F3AD}'));

const PORT = process.env.PORT || 10000;

async function startServer() {
  loadPlays();
  app.listen(PORT, async () => {
    console.log(`Server running on port ${PORT}`);
    if (url) {
      const webhookUrl = `${url}/webhook/${token}`;
      await bot.setWebHook(webhookUrl);
      console.log(`Webhook set to: ${webhookUrl}`);
    }
  });
}

startServer();

=== package.json ===
{
  "name": "play-by-text-bot",
  "version": "1.0.0",
  "description": "Classic plays delivered line by line via Telegram",
  "main": "bot.js",
  "scripts": {
    "start": "node bot.js"
  },
  "dependencies": {
    "node-telegram-bot-api": "^0.64.0",
    "express": "^4.18.2",
    "node-edge-tts": "^1.2.10"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}

=== README.md ===
# Play by Text 🎭

Great plays delivered line by line via Telegram.

## How it works

Users find 'Play by Text' on Telegram via username or direct link. They choose a play, then receive it one line at a time — like reading a text conversation. Each line has optional annotations explaining unobvious language, context, or other significance.

### Buttons

| Button | Function |
|--------|----------|
| ▽ | Advance to next line |
| 🔍 | Show annotation for current line |
| ⏸ | Manual mode — tap ▽ yourself |
| 🕯️ | Ambient mode — next line arrives in 10–60 min |
| ▶ | Active mode — next line arrives at ~reading pace |

Tapping the mode button cycles through all three modes. Replying `?` to any past line retrieves its annotation.

### Audio narration

Type `/audio` to toggle narration on or off. When on, each line is delivered with a voice message alongside the text. A dedicated narrator voice announces the character name, then the character's own voice reads the line. Stage directions are read entirely by the narrator.

Audio works in all delivery modes. In ambient mode, voice messages accumulate with the text — opening the app to several unread lines will play them back in sequence.

### Commands

| Command | Function |
|---------|----------|
| `/start` | Choose a play |
| `/plays` | List available plays |
| `/cast` | Show cast of current play |
| `/scenes` | Jump to a scene |
| `/audio` | Toggle audio narration on/off |
| `/help` | Show help |

## Adding new plays

Create a JSON file in the `/plays` folder named `{play-id}.json`.

### Structure

```json
{
  "id": "play-id",
  "title": "Play Title",
  "author": "Author Name",
  "emoji": "🎭",
  "description": "A general pitch for the play — shown when the user selects it.",
  "image": "https://url-to-cover-image.jpg",
  "introAnnotation": "Brief, spoiler free intro. Notes of interest, historical context, current relevance, etc.",
  "narrator": "en-GB-ThomasNeural",
  "defaultVoice": "en-GB-RyanNeural",
  "characters": {
    "Stage": { "emoji": "📜" },
    "Character Name": { "emoji": "🎭", "voice": "en-GB-RyanNeural" },
    "Another Character": { "emoji": "👑", "voice": "en-US-GuyNeural" }
  },
  "lines": [
    {
      "type": "stage",
      "sender": "Stage",
      "text": "Act I, Scene 1 — A brief location description."
    },
    {
      "type": "stage",
      "sender": "Stage",
      "text": "Stage direction in italics.",
      "annotation": "Explanation of this stage direction."
    },
    {
      "type": "character",
      "sender": "Character Name",
      "text": "The character's line.",
      "annotation": "Explanation of this line."
    }
  ]
}
```

### Scene headings

Each scene should begin with a stage direction line starting with "Act" — e.g. `"Act I, Scene 1 — A ship at sea."` or `"Act II — The nursery. Dawn."` for plays without scene divisions. The bot scans for these at load time to build the `/scenes` navigation index automatically. No extra metadata needed — just follow the convention and it works.

### Voice configuration

Audio uses [Microsoft Edge TTS](https://learn.microsoft.com/en-us/azure/ai-services/speech-service/language-support?tabs=tts) via the `node-edge-tts` package — free, no API key required.

| Field | Purpose |
|-------|---------|
| `narrator` | Voice for name announcements and stage directions (default: `en-GB-ThomasNeural`) |
| `defaultVoice` | Fallback voice for characters without a specific voice (default: `en-GB-RyanNeural`) |
| `characters.{name}.voice` | Character-specific voice |

Choose voices from [Microsoft's neural voice list](https://learn.microsoft.com/en-us/azure/ai-services/speech-service/language-support?tabs=tts). Pick voices with distinct accents, genders, or ages so characters are distinguishable. The narrator should sound different from all characters.

The characters map also accepts plain emoji strings (`"Boatswain": "⚓"`) for backward compatibility — these characters will use `defaultVoice` for audio.

### Tips for preparing plays

- **type**: `"stage"` for stage directions (rendered in italics), `"character"` for dialogue.
- **characters**: Define each speaker's emoji and voice once here — no need to repeat on every line.
- **annotation**: Most lines won't need one. Annotate when something would genuinely escape a modern reader: gloss difficult words, explain historical context, identify who's who, or flag structural significance (a callback, a real-world source). Keep it factual and specific. Don't tell readers what to feel about it. Stage directions that belong in the text (e.g. a character kneeling mid-scene) should be their own `"stage"` entry, not buried in an annotation.
- **image**: Optional cover image URL, shown when the play is selected.
- Keep lines reasonably short — this is messaging, not a book.
- Split long speeches into multiple messages.
- Stage directions like "Exit" or "Enter Mariners" are worth keeping — they give rhythm and breathing room.

## Hosting & architecture

### Current setup

- **Platform**: Render (free tier web service)
- **Runtime**: Node.js
- **Webhook**: Telegram webhook, set automatically on startup via `RENDER_EXTERNAL_URL`
- **Keep-alive**: UptimeRobot pings the `/health` endpoint to prevent Render free tier spindown

### Environment variables

| Variable | Purpose |
|----------|---------|
| `TELEGRAM_BOT_TOKEN` | Bot token from @BotFather |
| `RENDER_EXTERNAL_URL` | Public URL of the Render service |

### Key files

- `bot.js` — All bot logic (single file)
- `plays/*.json` — Play data, one file per play
- `images/` — Cover images (referenced by URL in play JSON)

### State & persistence

All user state is held in memory — no database. State resets on redeploy or restart. However, each ▽ button embeds the play ID and line index in its callback data, so Telegram remembers where the user is even after a restart.

TTS audio is cached by Telegram file_id after first generation — subsequent sends of the same line (to any user) are instant.

**Works fine after a restart:**
- Tapping ▽ on any existing message still delivers the correct next line
- Starting a new play works normally
- Audio preference resets to off (default)

=== plays/tempest.json (first 350 lines) ===
{
  "id": "tempest",
  "title": "The Tempest",
  "author": "William Shakespeare",
  "emoji": "🌊",
  "description": "magic, shipwreck, and revenge on a remote island",
  "image": "https://raw.githubusercontent.com/rstraker1/play-by-text-bot/master/images/tempest-1-opening-storm.jpg",
  "introAnnotation": "Written around 1610–11, The Tempest is believed to be the last play Shakespeare wrote on his own. It was partly inspired by real accounts of the Sea Venture, an English ship wrecked on Bermuda in 1609 while sailing to the Virginia colony. The play explores power, forgiveness, colonialism, and the nature of art itself — themes that feel remarkably current four centuries later. Unusually for Shakespeare, the plot appears to be entirely original rather than adapted from an existing source.",
  "narrator": "en-GB-ThomasNeural",
  "defaultVoice": "en-GB-RyanNeural",
  "dramatis": [
    "Prospero — the rightful Duke of Milan, exiled to a remote island",
    "Miranda — his daughter, raised on the island",
    "Ariel — a spirit bound to serve Prospero",
    "Caliban — a native of the island, enslaved by Prospero",
    "Alonso — King of Naples",
    "Ferdinand — his son",
    "Sebastian — Alonso's brother",
    "Antonio — Prospero's brother, usurper of his dukedom",
    "Gonzalo — an honest old counselor",
    "Adrian & Francisco — lords attending the King",
    "Trinculo — a jester",
    "Stephano — a drunken butler",
    "Shipmaster — captain of the ship",
    "Boatswain — officer in charge of the deck crew",
    "Iris, Ceres, Juno — spirits appearing in a masque"
  ],
  "characters": {
    "Stage": {
      "emoji": "📜",
      "voice": null
    },
    "Prospero": {
      "emoji": "📖",
      "voice": "en-GB-ElliotNeural"
    },
    "Miranda": {
      "emoji": "✨",
      "voice": "en-GB-LibbyNeural"
    },
    "Ariel": {
      "emoji": "🌬️",
      "voice": "en-GB-SoniaNeural"
    },
    "Caliban": {
      "emoji": "🪨",
      "voice": "en-AU-DarrenNeural"
    },
    "Alonso": {
      "emoji": "👑",
      "voice": "en-GB-RyanNeural"
    },
    "Ferdinand": {
      "emoji": "🪵",
      "voice": "en-US-AndrewNeural"
    },
    "Sebastian": {
      "emoji": "🐍",
      "voice": "en-US-ChristopherNeural"
    },
    "Antonio": {
      "emoji": "🎭",
      "voice": "en-US-GuyNeural"
    },
    "Gonzalo": {
      "emoji": "🧓",
      "voice": "en-GB-OliverNeural"
    },
    "Adrian": {
      "emoji": "🏛️",
      "voice": "en-US-BrandonNeural"
    },
    "Francisco": {
      "emoji": "🏛️",
      "voice": "en-US-DavisNeural"
    },
    "Trinculo": {
      "emoji": "🃏",
      "voice": "en-IE-ConnorNeural"
    },
    "Stephano": {
      "emoji": "🍷",
      "voice": "en-AU-WilliamNeural"
    },
    "Shipmaster": {
      "emoji": "🚢",
      "voice": "en-AU-WilliamNeural"
    },
    "Boatswain": {
      "emoji": "⚓",
      "voice": "en-GB-AlfieNeural"
    },
    "Iris": {
      "emoji": "🌈",
      "voice": "en-US-JennyNeural"
    },
    "Ceres": {
      "emoji": "🌾",
      "voice": "en-US-AriaNeural"
    },
    "Juno": {
      "emoji": "🕊️",
      "voice": "en-GB-MaisieNeural"
    },
    "Mariners": {
      "emoji": "⛵",
      "voice": "en-GB-AlfieNeural"
    }
  },
  "lines": [
    {
      "type": "stage",
      "sender": "Stage",
      "text": "Act I, Scene 1 — A ship at sea. A tempestuous noise of thunder and lightning heard.",
      "annotation": "The play opens in medias res — in the middle of the action."
    },
    {
      "type": "character",
      "sender": "Shipmaster",
      "text": "Boatswain!",
      "annotation": "Boatswain (pronounced 'BOH-sun'), the officer in charge of the deck crew and rigging."
    },
    {
      "type": "character",
      "sender": "Boatswain",
      "text": "Here, master. What cheer?",
      "annotation": "'What cheer?' means 'What's the situation?' or 'What are your orders?' — a common sailor's greeting."
    },
    {
      "type": "character",
      "sender": "Shipmaster",
      "text": "Good, speak to the mariners. Fall to't yarely, or we run ourselves aground. Bestir, bestir!",
      "annotation": "'Yarely' means quickly, nimbly. 'Bestir' means hurry, get moving."
    },
    {
      "type": "stage",
      "sender": "Stage",
      "text": "Enter Mariners."
    },
    {
      "type": "character",
      "sender": "Boatswain",
      "text": "Heigh, my hearts! Cheerly, cheerly, my hearts! Yare, yare! Take in the topsail. Tend to the master's whistle.",
      "annotation": "'Heigh, my hearts!' — a rallying cry, like 'Come on, lads!' 'Cheerly' means with spirit. 'Take in the topsail' — lower the sail near the top of the mast. The master's whistle signals commands."
    },
    {
      "type": "character",
      "sender": "Boatswain",
      "text": "Blow, till thou burst thy wind, if room enough!",
      "annotation": "He's addressing the storm directly: 'Blow as hard as you want — as long as we have sea room to maneuver.'"
    },
    {
      "type": "stage",
      "sender": "Stage",
      "text": "Enter Alonso, Sebastian, Antonio, Ferdinand, Gonzalo, and others.",
      "annotation": "The nobles stumble onto deck. Alonso is King of Naples. Sebastian is his brother. Antonio is Prospero's brother who usurped his dukedom. Ferdinand is the King's son. Gonzalo is an honest old counselor."
    },
    {
      "type": "character",
      "sender": "Alonso",
      "text": "Good Boatswain, have care. Where's the master? Play the men.",
      "annotation": "The King tries to take charge. 'Play the men' means 'put the men to work.' But he's giving orders on a ship he doesn't command."
    },
    {
      "type": "character",
      "sender": "Boatswain",
      "text": "I pray now, keep below.",
      "annotation": "'Please, stay below deck.' The Boatswain is too busy trying to save the ship to observe courtly manners."
    },
    {
      "type": "character",
      "sender": "Antonio",
      "text": "Where is the master, Boatswain?"
    },
    {
      "type": "character",
      "sender": "Boatswain",
      "text": "Do you not hear him? You mar our labour. Keep your cabins; you do assist the storm.",
      "annotation": "'You mar our labour' — you're getting in our way. 'You assist the storm' — you're making things worse by being here."
    },
    {
      "type": "character",
      "sender": "Gonzalo",
      "text": "Nay, good, be patient.",
      "annotation": "Gonzalo, the kind old counselor, urging patience — addressing his fellow nobles, not the crew."
    },
    {
      "type": "character",
      "sender": "Boatswain",
      "text": "When the sea is. Hence! What cares these roarers for the name of king? To cabin! Silence; trouble us not.",
      "annotation": "'Hence!' means go away. 'Roarers' — the roaring waves and wind. His point: the sea doesn't care about social rank."
    },
    {
      "type": "character",
      "sender": "Gonzalo",
      "text": "Good, yet remember whom thou hast aboard.",
      "annotation": "A reminder that the Boatswain is speaking to a king."
    },
    {
      "type": "character",
      "sender": "Boatswain",
      "text": "None that I more love than myself. You are a councillor; if you can command these elements to silence and work the peace of the present, we will not hand a rope more. Use your authority.",
      "annotation": "'If your political authority can calm the storm, go ahead — we'll stop working and watch.' He's testing the limits of earthly power against nature."
    },
    {
      "type": "character",
      "sender": "Boatswain",
      "text": "If you cannot, give thanks you have lived so long, and make yourself ready in your cabin for the mischance of the hour, if it so hap. Cheerly, good hearts! Out of our way, I say.",
      "annotation": "'Make yourself ready for the mischance of the hour' — prepare to die."
    },
    {
      "type": "stage",
      "sender": "Stage",
      "text": "Exit."
    },
    {
      "type": "character",
      "sender": "Gonzalo",
      "text": "I have great comfort from this fellow. Methinks he hath no drowning mark upon him; his complexion is perfect gallows.",
      "annotation": "Dark humor: Gonzalo finds comfort because the Boatswain looks destined for the gallows, not drowning. An old superstition held that a man born to hang can't drown. 'Perfect gallows' means his face is destined for the noose."
    },
    {
      "type": "character",
      "sender": "Gonzalo",
      "text": "Stand fast, good Fate, to his hanging. Make the rope of his destiny our cable, for our own doth little advantage. If he be not born to be hanged, our case is miserable.",
      "annotation": "Gonzalo continues his gallows joke: let Fate make sure this man hangs — because that would mean we survive this storm. 'Our cable' (anchor rope) isn't helping; maybe his destiny to hang will save us. If he's NOT destined to hang, we're doomed."
    },
    {
      "type": "stage",
      "sender": "Stage",
      "text": "Re-enter Boatswain.",
      "annotation": "The Boatswain returns as the storm reaches its peak. The nobles, instead of going below as ordered, have followed him back on deck."
    },
    {
      "type": "character",
      "sender": "Sebastian",
      "text": "A pox o' your throat, you bawling, blasphemous, incharitable dog!",
      "annotation": "'Incharitable' — lacking Christian charity. Sebastian loses his composure as the panic sets in."
    },
    {
      "type": "character",
      "sender": "Boatswain",
      "text": "Work you, then.",
      "annotation": "If you have a problem with how I'm doing it, do it yourself."
    },
    {
      "type": "character",
      "sender": "Antonio",
      "text": "Hang, cur! Hang, you whoreson, insolent noise-maker. We are less afraid to be drowned than thou art.",
      "annotation": "'Cur' — dog. 'Whoreson' — bastard. His claim that the nobles fear death less than the Boatswain is hollow bravado."
    },
    {
      "type": "character",
      "sender": "Gonzalo",
      "text": "I'll warrant him for drowning; though the ship were no stronger than a nutshell and as leaky as an unstanched wench.",
      "annotation": "Gonzalo continues his gallows joke: I guarantee the Boatswain won't drown — even if the ship were as flimsy as a nutshell with holes in it."
    },
    {
      "type": "character",
      "sender": "Boatswain",
      "text": "Lay her a-hold, a-hold! Set her two courses off to sea again; lay her off.",
      "annotation": "'Lay her a-hold' — steer close to the wind to avoid being driven onto rocks. 'Two courses' refers to the two lowest sails. A last attempt to maneuver clear."
    },
    {
      "type": "stage",
      "sender": "Stage",
      "text": "Enter Mariners, soaking wet.",
      "annotation": "The drenched sailors come up from below — a signal that the ship is already taking on water."
    },
    {
      "type": "character",
      "sender": "Mariners",
      "text": "All lost! To prayers, to prayers! All lost!",
      "annotation": "When the crew abandons seamanship for prayer, the situation is truly hopeless — or seems so."
    },
    {
      "type": "character",
      "sender": "Boatswain",
      "text": "What, must our mouths be cold?",
      "annotation": "A grim idiom: 'must we already be dead?' Cold mouths = corpses. He may be refusing to give up, or checking whether things are really as lost as the mariners say."
    },
    {
      "type": "character",
      "sender": "Gonzalo",
      "text": "The King and Prince at prayers! Let's assist them, for our case is as theirs.",
      "annotation": "Gonzalo reports that Alonso and Ferdinand are praying below and urges the others to join them."
    },
    {
      "type": "character",
      "sender": "Sebastian",
      "text": "I'm out of patience.",
      "annotation": "Sebastian's short temper resurfaces here — it becomes significant in Act II."
    },
    {
      "type": "character",
      "sender": "Antonio",
      "text": "We are merely cheated of our lives by drunkards. This wide-chapped rascal — would thou might'st lie drowning the washing of ten tides!",
      "annotation": "'Wide-chapped' means big-mouthed. 'The washing of ten tides' was the punishment for pirates — hanged at low water and left until three tides had washed over the body."
    },
    {
      "type": "character",
      "sender": "Gonzalo",
      "text": "He'll be hanged yet, though every drop of water swear against it and gape at widest to glut him.",
      "annotation": "Gonzalo holds to his gallows joke: the Boatswain is fated to hang, not drown — so every wave that tries to swallow him is wasting its time."
    },
    {
      "type": "stage",
      "sender": "Stage",
      "text": "A confused noise within: 'Mercy on us!' — 'We split, we split!' — 'Farewell, my wife and children!' — 'Farewell, brother!' — 'We split, we split, we split!'",
      "annotation": "'We split' — the hull is breaking apart."
    },
    {
      "type": "character",
      "sender": "Antonio",
      "text": "Let's all sink with the King."
    },
    {
      "type": "character",
      "sender": "Sebastian",
      "text": "Let's take leave of him.",
      "annotation": "'Take leave' carries a double meaning — farewell before dying, but also a parting with darker implications that emerge in Act II."
    },
    {
      "type": "stage",
      "sender": "Stage",
      "text": "Exeunt Antonio and Sebastian.",
      "annotation": "They leave Gonzalo alone onstage — the last man standing."
    },
    {
      "type": "character",
      "sender": "Gonzalo",
      "text": "Now would I give a thousand furlongs of sea for an acre of barren ground, long heath, brown furze, any thing. The wills above be done! But I would fain die a dry death.",
      "annotation": "'Long heath, brown furze' — thorny, useless moorland. Any solid ground at all. 'The wills above be done' — he surrenders to Providence, but would still rather not die wet."
    },
    {
      "type": "stage",
      "sender": "Stage",
      "text": "Exeunt. End of Act I, Scene 1.",
      "annotation": "The ship goes down — or seems to. Scene 2 opens on the island, where Prospero tells Miranda (and the audience) the truth: the tempest was his doing, and no one was harmed."
    },
    {
      "type": "stage",
      "sender": "Stage",
      "text": "Act I, Scene 2 — Before Prospero's cell. Enter Prospero and Miranda.",
      "image": null,
      "annotation": "The island. Prospero's 'cell' is a rough dwelling — cave or hut. He and Miranda have been watching the storm from a clifftop."
    },
    {
      "type": "character",
      "sender": "Miranda",
